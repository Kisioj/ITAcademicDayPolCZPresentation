<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>C# + Gothic + ANTLR4</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		
		<!-- From dziejekhorinis.org -->
		<link rel="stylesheet" href="css/hero-artwork.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal section img.clear { background:none; border:none; box-shadow:none; }
		</style>
	</head>
	<body>
		<div id="hero-artwork">
			<div class="background"></div>
			<div class="smoke"></div>
			<div class="first-plane"></div>
		</div>
		<img src="logo-horizontal.png" id="logo" alt="Gothic II Dzieje Khorinis">
		
		<div class="reveal">
			<div class="slides">
				<section class="stack">
					<section data-background-transition="slide">
						<h3>C# + Gothic + ANTLR4 -<br/>we're making the compiler!</h3><br/><br/>

						<aside class="notes">
							KJ: Cześć wszystkim, przyjechaliśmy dzisiaj do was z tematem C# + Gothic + ANTLR4, czyli tworzymy kompilator.
							Opowiemy wam dzisiaj o projekcie kompilatora, nad którym pracujemy po godzinach. Mamy nadzieje, że
							temat was zainteresuje, może nawet na tyle, że będziecie chcieli dołączyć do projektu i dołożyć do niego swoją cegiełkę.
							Zanim zaczniemy temat kompilatora, to opowiemy krótko o sobie i o projekcie Dzieje Khorinis.
							Zaczynajmy.
						</aside>
					</section>
					
					<section data-transition="zoom">
						<h2 style="text-align:left">About us</h2><br>

						<h4 class="fragment fade-in" style="text-align:left">Artur Kasperek</h4>
						
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; line-height: 1.95;" data-has-line-height="">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Dzieje Khorinis programmers coordinator</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">JS, TS Fullstack Freelance developer</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Computer Science student</li>
								</ul>
							</div>
						</div>
						<aside class="notes">
							AK: Mam na imię Artur Kasperek, pochodzę z Zawiercia. Na co dzień mieszkam w Gliwicach, w akademiku, jestem studentem Polsl.
							Pracuje w IT od ponad 3 lat, pod koniec gimnazjum zainteresowałem się programowaniem w c++, potem poszedłem na studia
							informatyczne, po pierwszym semestrze zacząłem pracować, zaczynałem jako stażysta robiąc frontend w angularze1.
							Następnie zaczął się zajmować także backendem i tak stałem się fullstackiem. Ostatnie miesiące spędzam
							na projekcie którego celeme jest dostarczenie softwaru dla agentów nieruchomiści ze stanów.

							Staram się brać udział w róźnych meetupach programistycznych, nie tylko jako słuchacz by cały czas się
							doskonalić
						</aside>
					</section>
					
					
					<section data-transition="zoom">
						<h2 style="text-align:left">About us</h2><br>

						<h4 class="fragment fade-in" style="text-align:left">Krzysztof Jura &lt;<a href="kisioj@gmail.com" target="_top">kisioj@gmail.com</a>&gt;</h4>
						
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; line-height: 1.95;" data-has-line-height="">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Software developer</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Programming teacher (C, C++, Python)</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">PyCzest  founder (<a href="https://fb.com/pyczest" target="_top">fb.com/pyczest</a>)</li>
								</ul>
							</div>
						</div>
						<aside class="notes">
							KJ: Ja nazywam się Krzysztof Jura, przyjechałem do was z Częstochowy, z Parkitki, czyli miałem dość niedaleko.

							Jeżeli chodzi o mnie to ja, programuję od 2007 roku, zaczynałem hobbistycznie od pisania sieciowych gier komputerowych 2D, a od ponad 5 lat pracuję w zawodzie, jako programista.
							Głównie zajmuję się tworzeniem aplikacji internetowych, zarówno po stronie backendu, który piszę w Pythonie, jak i po stronie frontendu, który oczywiście piszę w JavaScripcie.
							W ogóle, bardzo możliwe, że jakaś część z was korzysta na codzień z jakiś systemów nad którymi w przeszłości pracowałem, np. z systemu bankowego banku PKO BP.
							
							Oprócz tego, że programuję to od lat dorywczo zajmuję się nauczaniem programowania, zarówno prywanie jak i w szkołach programowania.

							Jestem też założycielem fanpage'a Częstochowskiej Społeczności Użytkowników języka Python. Obecnie na tym fanpage'u nic się nie dzieje, ale mamy w planach organizacje spotkań programistów Pythona, a w najbliższej przyszłości będziemy organizowali darmowe warsztaty z programowania w języku Python. Warsztaty będą dla każdego niezależnie od płci, wieku, rasy, wyznania, orientacji seksualnej czy poglądów politycznych, więc każdego zainteresowanego zapraszam do polubienia fanpage'a i oczekiwania na dalsze informacje.
						
							I to by było na tyle jeżeli chodzi o nas prywatnie, natomiast chciałbym jeszcze opowiedzieć o projekcie w którym oboje z Arturem bierzmy udział.
						</aside>
					</section>
					
					<section data-transition="slide">
						<img src="logo-horizontal.png" class="logo" style="max-height: 250px;">
						<img src="dkscreen.jpg" style="max-height: 300px;">
						
						<aside class="notes">
							KJ: Projekt ten nazywa się Gothic II Dzieje Khorinis. Bardzo możliwe, że już słyszeliście tą nazwę bo jest o nas dość głośno.
							Tak w skrócie: robimy moda do kultowej gry o nazwie Gothic II. W naszym zespole mamy kilkadziesiąt osób, w tym m.in. programistów, scenarzystów, grafików, animatorów i pewnie jeszcze kilka innych typów osób. Natomiast nadal szukamy ludzi, więc jeżeli ktoś jest chętny nas wesprzeć to możemy pogadać o tym po tej prezentacji. Warto dodać, że projekt jest non profit, to znaczy nie dostajemy żadnych pieniędzy za pracę; po prostu pracujemy bo chcemy zrobić coś fajnego.
							
							Jeżeli chodzi o historię projektu to pomysł na zrobienie moda powstał w 2008 roku, ale dopiero pod koniec roku 2015 rozpoczęły się nad nim prace.
							Natomiast zgromadzenie zespołu w takim kształcie w jakim mniej więcej teraz jest to w zasadzie kwestia ostatniego roku.
							
							Z takich ciekawostek to: do naszego moda głosów udzielają profesjonalni aktorzy głosowi, w tym również Ci, którzy podkładali głos postaciom z oryginalnej wersji gry.
							
							Oprócz samego moda, w naszym zespole pracujemy również nad narzędziami związanymi z modowaniem Gothica. Głównym językiem, który wykorzystujemy w tych narzędziach jest C#, a o samych narzędziach opowie wam Artur.
							
						</aside>
					</section>
				</section>
				
				<section data-transition="slide">
					<h3 style="text-align:left">Tools</h3><br>
					<div class="sl-block" data-block-type="text">
						<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
							<ul>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">3D World Editor</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Mod Package Builder</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Translation Tool</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Daedalus Compiler</li>
							</ul>
						</div>
					</div><br>
					
					<aside class="notes">
							AK: Narzędzi, które tworzymy jest dość dużo, natomiast takie główne 3 narzędzia to przede wszystkim:
							
							- Edytor Światów, który ma w założeniu być dużo bardziej rozbudowanym i dopracowanym edytorem niż ten dołączony do Gothica. Ten Gothicowy wiecznie się zawiesza, chodzi bardzo topornie i częśc społeczności generalnie klnie na niego.

							- Kolejnym naszym projektem jest narzędzie do budowania paczki z modem, które zbiera do kupy cały kod projektu, mapy, modele i inne rzeczy i buduje z nich paczkę o oczekiwanym przez Gothica formacie.

							- Pracujemy także nad narzędziem które pozwoli w łatwiejszy sposób dodać lokalizacje językowe, obecnie by dodać nową wersję językową tłumacz musi grzebać bezpośrednio w skryptach i np podmieniać literały, co grozi bugami w danej wersji językowe

							- No i ostatnim narzędziem jest Kompilator języka Daedalus, o którym dzisiaj wam troszkę więcej opowiemy.
					</aside>
				</section>
				
				
				
				
				<section class="stack">
					<section data-transition="slide">
						<h3>Daedalus</h3><br>
						<img class="fragment fade-in" src="wtfmeme.png" style="max-height: 300px;">
						
						<aside class="notes">
							Pytanie do publiczności: czy ktoś z was w ogóle słyszał o takim języku jak Daedalus?
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3 style="text-align:left">Daedalus</h3><br>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Gothic I and II scripting language</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">has C-like syntax</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">compiled to Daedalus bytecode</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">have externals which call engine functions directly</li>
								</ul>
							</div>
						</div><br>
						
						<aside class="notes">
							Daedalus którego nazwa pochodzi od mitycznego Dedala to po prostu język skryptowy gier Gothic I i Gothic II, czyli język w którym pisze się mody do tych gier.
							
							Jego składnia została zainspirowana składnią języka C co widać już na 1 rzut oka.
							
							A kod tego języka jest kompilowany do kodu bajtowego, wykonywanego w trakcie gry przez maszynę wirtualną zawartą w grze Gothic.

							Za pomocą externali jest możliwe wywołanie różnych funkcji które są zaimplementowane na poziomie silnika, np logi
							
							<!--
							Mówimy że dzięki skryptom w D komuniukujemy się z silnkiem gry,
							w D istnieją internale do silnika, np AI_output które sterują zachowaniem
							silnika. Typowa architektura jak dla gier koło 2000 roku, Quake 3 podobnie działa ( C QUAKE )
								-->
						</aside>
					</section>

					
					<section data-background-transition="slide">
						<pre><code data-trim data-noescape>
instance PC_Thief_DI(Npc_Default)
{
  name[0] = "Diego";
  guild = GIL_NONE;
  npcType = NPCTYPE_FRIEND;
  aivar[AIV_ToughGuy] = TRUE;
  B_SetAttributesToChapter(self,6);
  fight_tactic = FAI_HUMAN_MASTER;
  EquipItem(self,ItMw_1h_Sld_Sword);
  daily_routine = Rtn_Start_31;
  ...
};
		</code></pre>

						<aside class="notes">
							Tutaj widzicie przykładowy kod w języku Daedalus. Jest to kod definiujący instancję NPCta, którego później w trakcie gry będziemy mogli spotkać na mapie.
							
							Ustalamy tutaj imie tego NPCta, jego model 3D, zachowanie, statystyki i inne parametry.
						</aside>
					</section>
					
					
					
					<section data-background-transition="slide">
						<pre><code data-trim data-noescape style="overflow: hidden;">
func void DIA_MIL_6_STANDARD_Info()
{
  AI_Output(other,self,"DIA_MIL_15_00");  //Co słychać?
  if(Kapitel == 1)
  {
    AI_Output(self,other,"DIA_MIL_06_01"); //W mieście coraz więcej szumowin.
    AI_Output(self,other,"DIA_MIL_06_02"); //Wszędzie coraz więcej złodziei. Lord Andre podejrzewa nawet, że całe to zamieszanie jest sprawką gangu.
    AI_Output(self,other,"DIA_MIL_06_03"); //Niedawno przetrząsnęliśmy dokładnie całą dzielnicę portową, ale niczego nie znaleźliśmy.
  }
  else if(Kapitel == 2)
  {
    AI_Output(self,other,"DIA_MIL_06_04"); //Wygląda na to, że problem bandytów mamy już z głowy. Ataki stały się ostatnimi czasy rzadkością.
  };
};
		</code></pre>

						<aside class="notes">
							Kolejny przykład kodu przedstawia funkcję dialogową zawierającą kwestie wypowiadane przez naszą postać oznaczoną przez self oraz przez postać z którą rozmawiamy oznaczoną przez other.
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Daedalus Compiler</h3><br>
						<img class="fragment fade-in" src="butwhy.gif" style="height: 300px; width: 550px; object-fit: cover;">
						
						<aside class="notes">
							No dobra, wiemy czym jest język Daedalus, ale pytanie brzmi: dlaczego w ogóle chcieliśmy stworzyć nowy kompilator tego języka?
							
							Powodów jest kilka.
							
							<!-- Skrypter nie może szybko przekompilować rzeczy bez odpalania gry, musi przewinąć intro
							Nie możemy przez to łatwo postawić stagingu który by testował automatycznie czy
							skrypty są kompilowanlne w naszym pipeline -->
							
							<!-- Kompilator będzie dopełnieniem narzędzia do budowania gry ( robocza nazwa gothic mod composer ).
							Dzięki temu nawet niedoświadczony skrypter będzie mógł w prosty sposób zacząć zabawę z modowaniem
							gothica -->
							
							Jednym z głównych powodów jest to, że oryginalny kompilator jest wbudowany w grę Gothic i żeby skompilować skrypty trzeba tą grę najpierw uruchomić - co jest dość niefajne,
							bo po pierwsze trzeba mieć zainstalowanego Gothica, a po drugie, po prostu gorzej się z takiego kompilatora korzysta - no bo trzeba za każdym razem czekać na uruchomienie gry, a potem wyjść z gry.
							
							Kolejna sprawa to jest to, że błędy wyświetlane przez oryginalny kompilator są często dość niejasne i enigmatyczne i w naszym kompilatorze chcielibyśmy to zrobić lepiej.
							
							No a poza tym sam język Daedalus w wersji dla oryginalnego kompilatora jest językiem dość mocno ograniczonym, więc mamy pomysł aby nasz kompilator potrafił obsługiwać bardziej rozbudowaną wersję tego języka, ale zachowując kompatybilność wsteczną , to znaczy, że oryginalny kod w języku Daedalus również działałby u nas bez problemu.
						</aside>
					</section>
					

					
					<section data-transition="slide">
						<h3 style="text-align:left">Daedalus flaws</h3>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">no for or while loop</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">has classes but no methods</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">requires ; after }</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">constants can be modified</li>
								</ul>
							</div>
						</div>
						
						<aside class="notes">
							Jakie są te ograniczenia języka Daedauls, których chcielibyśmy się pozbyć w naszej wersji języka?
							
							Jest ich generalnie bardzo dużo, a kilka takich pierwszych z brzegu, które od razu przychodzą na myśl to np. to, że:
							
							- w języku Daedalus nie ma pętli, ani for, ani while, ani foreach, ani żadnej innej, natomiast w naszej wersji języka chcemy je dodać
							
							- kolejne ograniczenie to to, że w Daedalusie istnieją klasy, natomiast nie mogą posiadać one metod, więc są de facto tylko stukturami danych i chcielibyśmy to zmienić

							- Kolejna sprawa to to, że oryginalny kompilator wymaga umieszczania średników po zamykających nawiasach wąsatych, co może być dość wkurzające dla programistów innych języków nieprzyzwyczajonych do takich rzeczy.
							
							- również dziwną rzeczą jest to, że stałe można w języku Daedalus modyfikować, a od zmiennych różnią się one tym, że nie są zapisywane w save'ach. My raczej nie będziemy chcieli dawać programistom możliwości zmiany wartości stałych.

							
							Genealnie tych ograniczń języka Daedalus jest dużo dużo więcej, więc naprawdę możemy ten język bardzo ulepszyć i mam nadzieję, że nam się to uda.
							
							No dobra, wróćmy do głównego tematu: czyli do tematu tworzenia kompilatora. Ale najpierw zadam pytanie: czy każdy z was wie czym dokładnie jest kompilator? Pewnie nie każdy.
						</aside>
					</section>
				</section>

				<section class="stack">
					<section data-transition="slide">
						<h3>Compiler</h3>
						<p class="fragment fade-in">A compiler is computer software that transforms computer code written in one programming language (the source language) into another programming language (the target language).</p>
						
						<aside class="notes">
							A więc pozwólcie, że przedstawie wam definicje z angielskiej wikipedii, która mówi, że kompilator to jest program, który zamienia kod napisany w jednym języku programowania na kod w innym języku programowania.
							
							Zazwyczaj jednak jak mówimy o kompilatorze  to mamy na myśli coś w stylu kompilatora np. języka C, czyli chodzi nam o program, który zamienia kod źródłowy na kod maszynowy, czyli instrukcje zrozumiałe dla procesora naszego komputera,

							albo często też chodzi nam o program, który zamienia kod źródłowy na kod bajtowy, który potem jest wykonywany przez maszynę wirtualną i tak jest np. w przypadku np. Javy albo właśnie języka Daedalus.
						</aside>
					</section>
					
					

					
					
					
					<section data-transition="slide">
						<h3>How does the compiler work?</h3>
						
						<aside class="notes">
							No dobra, ale jak kompilator działa pod spodem? Otóż należy zacząć od tego, że kompilator to taki program, który jak sama nazwa wskazuje, potrafi wykonać proces kompilacji jakiegoś kodu źródłowego - czyli ten proces zamiany kodu źródłowego na kod zrozumiały przez procesor lub maszynę wirtualna.
							
							Proces kompilacji składa się z kilku głównych kroków. Kroków tych może być więcej, lub mniej, w zależności od kompilatora, natomiast podstawowe kroki, które wykorzystujemy w naszym kompilatorze są następujące:
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Compilation</h3>
						<div class="fragment fade-in">
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">1. lexical analysis</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">2. parsing (syntactic analysis)</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">3. semantic analysis, IR generation</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">4. code generation</p>
						</div><br>

						<aside class="notes">
		
						</aside>
					</section>
					
					<!--
					
					<section data-transition="slide">
						<h3>Compilation steps</h3>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">preprocessing</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">lexical analysis</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">parsing</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">semantic analysis</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">intermediate form generation</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">optimization</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">code generation</li>
								</ul>
							</div>
						</div>
						
						<aside class="notes">
		
						</aside>
					</section>
					-->
					
					<!-- - Pierwszym krokiem jest tkz. preprocessing, czyli przetworzenie kodu źródłowego za pomocą dyrektyw preprocesora. Jeżeli ktoś z was pisał kod w C albo w C++ to chodzi o komendy zaczynające się od hashtaga, np. define albo include. W naszym kompilatorze póki co tego kroku nie ma i najprawdopodobniej nie będzie. -->
					
					<section data-transition="slide">
						<h3>1. Lexical analysis</h3>
						<div style="align-items: center; display: flex;">
						
						<pre class="fragment fade-in" style="width:35%; float:left;"><code data-trim data-noescape style="overflow: hidden;">
func void testFunc() {
  var int x;
  x = HLP_Random(100);
  if (x >= 50) {
    Print("You win!");
  } else {
    Print("You lose");
  };
};
			</code></pre>
			
			<p class="fragment fade-in" style="float: left;margin-left: 2%;margin-right: 1%;padding: 0; font-size:200%">🡆</p>
			
			<pre class="fragment fade-in" style="width:52%; float:left; font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
Token('func', &lt;FUNC>&gt;
Token('void', &lt;VOID>&gt;
Token('testFunc', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('var', &lt;VAR>&gt;
Token('int', &lt;INT>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('=', &lt;ASSIGN>&gt;
Token('HLP_Random', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('100', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('if', &lt;IF>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('>=', &lt;GREATER_THAN_EQUALS>&gt;
Token('50', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You win!"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token('else', &lt;ELSE>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You lose"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
			</code></pre>
			
			
						</div>
						<aside class="notes">
							Pierwszym krokiem jest analiza leksykalna
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3>2. Parsing (syntactic analysis)</h3>
						
						<img class="fragment fade-in" src="antlr4_parse_tree.png" style="background: white;">
						
						<aside class="notes">
							Kolejnym krokiem jest analiza składniowa (inaczej parsowanie)
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>3. Semantic analysis</h3>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int random;
radom = 5;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int num;
num = "five";
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int x;
var int x;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var C_NPC person;
person = HLP_GetNpc(PC_Thief_DI);
person.qold = 100;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
func int testFunc() {};
						</code></pre>
						<aside class="notes">
							Kolejnym krokiem jest analiza semantyczna
						</aside>
					</section>
					
					<section data-transition="slide">
						<h4>3. Intermediate representation generation</h4>
						
						<div class="fragment fade-in" style="align-items: center; display: flex;">
						<pre style="width:32%; float:left;  font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
func void testFunc() {
  var int x;
<mark style="background: darkolivegreen;">  x = HLP_Random(100);</mark>
<mark style="background: darkslateblue;">  if (x >= 50)</mark>
<mark style="background: brown;">  {
    Print("You win!");
  }</mark>
<mark style="background: darkslategrey;">  else</mark>
<mark style="background: saddlebrown;">  {
    Print("You lose");
  };</mark>
<mark style="background: darkcyan;">};</mark>
			</code></pre>
			
			<p style="float: left;margin:0;padding: 0; font-size:100%">🡆</p>
			
			<pre style="width:35%; float:left; font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
<mark style="background: darkolivegreen;">PushInt(100)
CallExternal(HLP_Random)
PushVar(testFunc.x)
Assign()</mark>
<mark style="background: darkslateblue;">PushInt(50)
PushVar(testFunc.x)
GreaterOrEqual()
JumpIfToLabel("label_0")</mark>
<mark style="background: brown;">PushVar(˙10000)
CallExternal(Print)
JumpToLabel("label_1")</mark>
<mark style="background: darkslategrey;">AssemblyLabel("label_0")</mark>
<mark style="background: saddlebrown;">PushVar(˙10001)
CallExternal(Print)
AssemblyLabel("label_1")</mark>
<mark style="background: darkcyan;">Ret()</mark>
			</code></pre>
			
						<pre style="width:25%; float:left; font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
<mark style="background:rgb(40,40,40);">HLP_Random
...
Print</mark>
testFunc
testFunc.x
˙10000 "You win"
˙10001 "You lose"
			</code></pre>
			
						</div>
						<aside class="notes">
							Generowanie formy pośredniej, czyli uzupełnienie struktur w kodzie danymi, z których później w łatwy sposób będzie można wygenerować kod bajtowy.
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3>4. Code generation</h3>
						
						<img class="fragment fade-in-then-disappear" src="hxdhighlight.png">
						
						<div class="fragment fade-in" style="align-items: center; display: flex;">
						<pre style="width:35%; float:left; font-size: 0.50em; margin-left:15%;"><code data-trim data-noescape style="overflow: hidden;">
PushInt(100)
CallExternal(HLP_Random)
PushVar(testFunc.x)
Assign()
PushInt(50)
PushVar(testFunc.x)
GreaterOrEqual()
JumpIfToLabel("label_0")
PushVar(˙10000)
CallExternal(Print)
JumpToLabel("label_1")
AssemblyLabel("label_0")
PushVar(˙10001)
CallExternal(Print)
AssemblyLabel("label_1")
Ret()
						</code></pre>
						<p style="float: left;margin:0;padding: 0; font-size:100%">🡆</p>
						<pre style="width:35%; float:left; font-size: 0.50em;  margin-right:15%;"><code data-trim data-noescape style="overflow: hidden;">
40 64 00 00 00
3E 57 02 00 00
41 AC 03 00 00
09
40 32 00 00 00
41 AC 03 00 00
12
4C 2F 00 00 00
41 AD 03 00 00
3E 0C 00 00 00
4B 39 00 00 00

41 AE 03 00 00
3E 0C 00 00 00

3C
						</code></pre>
						</div>
						
						
						<aside class="notes">
							Ostatnim krokiem jest wygenerowanie kodu, w naszym przypadku to będzie kod bajtowy dla maszyny wirtualnej Gothica.
						</aside>
					</section>
					
					<section data-background-transition="slide">
						<h3>Let's make a compiler</h3><br>
						<h4 class="fragment fade-in" style="text-align:left;">Q: What do I need?</h3>
						<h4 class="fragment fade-in" style="text-align:left;">A: ANTLR4!</h3>
						<br><br>
						<aside class="notes">
						</aside>
					</section>
					

					
					
					
				</section>
				
				<section class="stack">
					<section>
						<h3>What our compiler can do for now moment ?</h3>
						<ul>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Load SRC file</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Compile Daedalus code and generate DAT file</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Detect errors with default ANTLR error strategy</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Generate CSL files ( Gothic Engine Dialog file )</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Generate readable assembler (WIP)</li>
						</ul>

						<aside class="notes">
							Nad kompilatorem pracujemy już około 9 miesięcy, przez ten czas udało nam się już trochę osiągnąć.

							Udało nam się z suksecem załadować pełne skrypty Gothica II i wygenerować plik DAT który jest taki sam jak plik tworzony przez oryginalny kompilator. Dodatkowo nasz kompilator jest szybszy od oryginalnego.

							Dzięki antlr'owi mamy zaimplementowane wykrywanie błędów leksykalnych i semantycznych. Pracujemy nad ulepszeniem wykrywanie błędów semantycznych, ponieważ nie wszystkie da się wyłapać podczas procesu parsowania

							Generujemy pliki CSL. Są one tworzone na podstawie komenatrzy które są w kodzie. WIem że to dość dziwaczne trzymać w komentarzach dialogi ale było to wymyślane w 1999.

							Gdy dodamy odpowednią flagę zamiast pliku DAT generujemy pośredni assembler, który jest w pełni czytelny przez człowieka, ten feature wymaga dopracowania.

						</aside>
					</section>
					<section>
						<h3>Demo</h3>
						<img class="fragment fade-in-then-semi-out" src="demo.gif">

						<aside class="notes">
							Teraz czas na demo :). Dla pewności zrobiłem nagranie terminala w postaci GIFa. Zobaczmy co na nim jest

							Na początku tworzymy plik Gothic.src, plik ten zawiera inforamcji o lokalizacji naszych wszystkich źródeł.
							Następnie dodajemy plik z Daedalusem, dodajemy w nim testową funkcję, robimy operacje na lokalnej zmiennej

							Dalej kompilujemy plik src kompilatorem, kompilator mówi nam o braku średnika

							Poprawiamy to, kompilujemy jeszcze raz, tym razem kompilator kompiluje z sukcesem i generuje folder output

							W nim znadjuje się plik DAT, plik DAT jest plikiem binarnym z kodem maszynowym.
						</aside>
					</section>
					<section style="font-size: 80%">
						<h3>Some interesting problems during development</h3>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with encoding ( Gothic Script were written originally written in windows 1250 encoding  )
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with INSTANCE_HELP symbol name ( in byte code it's prefixed with fixed char, value of that char is 255  )
							<br/><br/><img width="400" src="instanceHelpProblem.png">
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with slow compilation speed ( changing List to Dictionary resolved problem  )
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							dotNet Directory.GetFiles method by default works differently on different OS
						</li>

						<aside class="notes">
							Podczas developmentu napotkaliśmy kilka ciekawych problemów.

							Odkryliśmy, że skrypty gothica nie są kodowane w utf8, a w windows 1250. Pod koniec lat 90 utf8 nie było jeszcze
							tak popularne. Na szczęście w netcore w prosty sposób można wczytać stringa w kodowaniu 1250, tak samo w prosty sposób
							można przekonwertować spowrotem stringa do 1250

							Napotkaliśmy na problem z nazwą zmiennej w wynikowym pliku DAT. Mianowicie po kompilacji zmienna ta dostawała nowy znak do nazwy.
							Nasz kompilator czegoś takiego nie robił, skąd wyszły niezgodności między naszym DATem, a DATem oryginlnaego kompilatora,
							prostym IFem naprawiliśmy problem, na szczęście to jedyny taki przypadek z dodawaniem prefixów przez kompilator

							W pierwszych wersjach nasz kompilator strasznie powoli działał, okazało się że problem jest podczas przeszukiwania
							listy z symbolami, zamiana tejże listy na słownik przyspieszyła proces kompilacji kilkukrtonie

							Podczas testów na MacOS napotkałem na problemy. Okazało się że pliki są czytane w innej kolejnosci niż na windowsie, a
							to ma ogromne znaczenie podczas kompilacji, bo musi być zachowana prawidłowa kolejność parsowania plików,
							problem wynikał z wildcardów które są wspierane w plikach SRC. Funckja Directory.GetFiles jako jeden z argumentów ma
							pattern, w którym mozemy podać wildecard, na windowsie gdy mamy sytuacje że nazwa pliku jest prefixem innego pliku,
							to na posortowanej liście pierwszy będzie plik o dłuższej nazwie, na macOS działa to odwrotnie, pierwszy na liście będzię
							plik o krótszej nazwie, ten który jest prefixem
						</aside>
					</section>
					<section>
						<h3>Things about Daedalus discovered during compiler development</h3>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Operation on floats are limited
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Statement of IF block does't have to be surrounded with brackets, ex:
							<pre><code data-trim data-noescape>
if 5 < 2 {
};
							</code></pre>
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Gothic Compiler support expression without assigment
							<pre><code data-trim data-noescape>
if ( a > b ) {
  b;
};
							</code></pre>
						</li>

						<aside class="notes">
							Dzięki pracy nad kompilatorem udało nam się dowiedzieć kilka ciekawych rzeczy.

							Obsługa floatów jest bardzo kiepska. De facto to głównie służą jako parametry do różnych rzeczy w silniku.
							Nie ma na poziomie VM instukcji które pozwalałyby robić porównania floatów, czy też operacji dodawania etc

							Nie jest wymogiem dawanie nawiasów do wyrażeń w blokach warunkowych. Na początku myśleliśmy że jest to jakiś bug
							oryginlnaego kompilatra że na coś takiego pozwala, ale jak się później okazało to jednak feature ;). De facto
							tylko w jednym wyrażeniu twórcy gothica pokusili się o taką składnię.

							W gothicu dozwolne jest użycie wyrażenia w którym podajemy samą prawą wartość, w takim przypadku po prostu
							na stos jest wrzucana zmienna b, i nic wiecej. De facto taki kod nic nie robi, także trochę nie ma sensu,
							w oryginlnych skryptach gothica jest tylko takie jedno miejsce z takim expression
						</aside>
					</section>
					<section>
						<h3>What we plan to add ?</h3>
						<ul>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Better error handling
								<ul>
									<li>Lexical errors</li>
									<li>Semantic errors</li>
								</ul>
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add booleans ( software support )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add loops (for, while, foreach)
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Possibility to define methods in classes
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add translation string ( feature needed for translation tool )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add operations on float ( software support )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								And ... features suggested by You, community and all Daedalus users ;)
							</li>
						</ul>

						<aside class="notes">
							Planujemy rozszerzyć Daedalus o kilka istotnych funkcji.

							Chcielibyśmy ulepszyć wylrywanie błędów. Obecnie nie robimy analizy typów, co jest must have.
							Dodatkowo myślimy nad zmianą domyślnej strategi antlr związanej z detekcją błędów podczas
							parsowania kodu, dzięki czemu moglibyśmy mieć bardziej customową obsługę błędów.

							Dodać booleany. Niestety nie jest to możliwe na poziomie VM, także pod spodem byłyby
							dalej inty

							Dodać pętle, co ciekawe twórcy nie zdecydowali się na ich dodanie, w niektórych miejscach
							takowe pętle uprościłyby kod skrytpów

							Możliwość dodawania metod do klas, na dzień obecny można jedynie dodawać pola z wartościami do klas

							Obecnie niektóre teksty ktróre są wyswietlane w grze są trzymane jako literały Daedalusa. Przez to
							tłumacz musi grzebać w rzeczach abstrakcyjnych dla niego i dodatkowo może popsuć skrypty. Planujemy
							dodać mechanizm który pozwoli wyciągnać te teksty do zewnętrznych plików

							Planujemy dodać możliwość operacji na floatach, dzięki temu skrypterzy mieliby większe możliwości

							Także wy możecie zadecydować co chcecie zobaczyć w nowym Daedalusie. Jesteśmy otwarci na sugestie
						</aside>
					</section>
				</section>
				<section class="stack">
					<section style="font-size: 90%">
						<h3>Do we write tests ?</h3> <br/>
						<img class="fragment fade-in" width="500" src="testMeme.jpg"><br/>
						<h3 class="fragment fade-in">Just kidding!</h3>
						<h3 class="fragment fade-in">Yes, we do!</h3>
						<h3 class="fragment fade-in">And their helped us!!</h3>

						<aside class="notes">
							Pewnie się zastanawialiście się czy piszemy testy.

							Po cholere je pisać ...

							Nie no, żart, piszemy testy

							I myślę że warto, mieliśmy sytaucje że robiliśmy refactor, dzięki testom było to o wiele łatwieszje. Mamy też większą
							pewność że nowe featury nie zepsują obecnie dziajłająych rzeczy. Dodatkowo po dłuższej przerwie z kodem spoglądając na
							testy, może sobie przypomnieć jak wygląda i działa assembler VM daedalusa
						</aside>
					</section>
					<section>
						<h3>We write unit tests</h3>
						<img width="800" class="fragment fade-in" src="unitTest.png">
						<aside class="notes">
							W unit testach większość test casów ma kod w stringu Daedalusa oraz oczekiwane instrukcje kodu pośredniego,
							w teście uruchamiamy kompilator dla tego stringa i sprawdzamy czy instrukcje IR są takie jakie powinny być wygenerowane
						</aside>
					</section>
					<section>
						<h3>We write e2e tests</h3>
						<img src="e2eTest.png">
						<aside class="notes">
							W testach e2e międzyinnymi porównujemy czy plik DAT stworzony przez oryginalengo gothica jest zgodny
							z plikiem DAT stworzonym przez nas
						</aside>
					</section>
					<section>
						<h3>We use CircleCI for automation</h3>
						<img src="circleci.png">
						<aside class="notes">
							Projekt trzymamy na Githubie, dzięki circleCi możemy w bardzo prosty sposób odpalać testy za każdym razem gdy robimy
							merge, albo wysyłamy kod na dany branch
						</aside>
					</section>
					<section>
						<h3>Thanks to:</h3>
						<img width="300" src="dotnetcore.png">
						<div class="fragment fade-in">
							<h3>We can run compiler on:</h3>
							<img width="600" src="OS.png">
						</div>
						<aside class="notes">
							Dzięki temu że kompilator jest pisany w technologii dotnet core możemy uruchomić go na wszystkich znacząych systemach.
							Wcześniej było to możliwe na windowsie, ponieważ kompilator jest wbudowany w gothic2.exe, a gothic2.exe działa tyko na windowsie,
							zapominając o tym że jest coś takiego jak wine, uruchomienie na wine wymaga trochę kombinacji
						</aside>
					</section>
				</section>
				
				<section>
					<h3>We need C# programmers</h3>
				</section>
				
				<section>
					<h3>Thank you and Bye</h3> <br />
					<h3 class="fragment fade-in">Questions ?</h3>
					<br /><br />
					<img width="200" src="ghLogo.png"><br/>
					<a href="https://github.com/dzieje-khorinis/DaedalusCompiler">github.com/dzieje-khorinis/DaedalusCompiler</a>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

			// setTimeout(() => {
            //   Reveal.navigateTo(4)
			// }, 500);
		</script>
	</body>
</html>
