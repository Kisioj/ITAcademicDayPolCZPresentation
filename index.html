<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>C# + Gothic + ANTLR4</title>
		
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		
		<!-- From dziejekhorinis.org -->
		<link rel="stylesheet" href="css/hero-artwork.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal section img.clear { background:none; border:none; box-shadow:none; }
		</style>
	</head>
	<body>
		<div id="hero-artwork">
			<div class="background"></div>
			<div class="smoke"></div>
			<div class="first-plane"></div>
		</div>
		<img src="rsc/LogoDK.png" id="logo" alt="Gothic II Dzieje Khorinis">
		
		<div class="reveal">
			<div class="slides">
				<section class="stack">
					<section data-background-transition="slide">
						<h3>C# + Gothic + ANTLR4 -<br/>we're making the compiler!</h3><br/><br/>

						<aside class="notes">
							KJ: Cześć wszystkim, przyjechaliśmy dzisiaj do was z tematem C# + Gothic + ANTLR4, czyli tworzymy kompilator.
							Opowiemy wam dzisiaj o projekcie kompilatora, nad którym pracujemy po godzinach. Mamy nadzieje, że
							temat was zainteresuje, może nawet na tyle, że będziecie chcieli dołączyć do projektu i dołożyć do niego swoją cegiełkę.
							Zanim zaczniemy temat kompilatora, to opowiemy krótko o sobie i o projekcie Dzieje Khorinis.
							Zaczynajmy.
						</aside>
					</section>
					
					<section data-transition="zoom">
						<h2 style="text-align:left">About us</h2><br>

						<h4 class="fragment fade-in" style="text-align:left">Artur Kasperek</h4>
						
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; line-height: 1.95;" data-has-line-height="">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Dzieje Khorinis programmers coordinator</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">JS, TS Fullstack Freelance developer</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Computer Science student</li>
								</ul>
							</div>
						</div>
						<aside class="notes">
							AK: Mam na imię Artur Kasperek, pochodzę z Zawiercia. Na co dzień mieszkam w Gliwicach, w akademiku, jestem studentem Polsl.
							Pracuje w IT od ponad 3 lat, pod koniec gimnazjum zainteresowałem się programowaniem w c++, potem poszedłem na studia
							informatyczne, po pierwszym semestrze zacząłem pracować, zaczynałem jako stażysta robiąc frontend w angularze1.
							Następnie zaczął się zajmować także backendem i tak stałem się fullstackiem. Ostatnie miesiące spędzam
							na projekcie którego celeme jest dostarczenie softwaru dla agentów nieruchomiści ze stanów.

							Staram się brać udział w róźnych meetupach programistycznych, nie tylko jako słuchacz by cały czas się
							doskonalić
						</aside>
					</section>
					
					
					<section data-transition="zoom">
						<h2 style="text-align:left">About us</h2><br>

						<h4 class="fragment fade-in" style="text-align:left">Krzysztof Jura &lt;<a href="kisioj@gmail.com" target="_top">kisioj@gmail.com</a>&gt;</h4>
						
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; line-height: 1.95;" data-has-line-height="">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Software developer</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Programming teacher (C, C++, Python)</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">PyCzest  founder (<a href="https://fb.com/pyczest" target="_top">fb.com/pyczest</a>)</li>
								</ul>
							</div>
						</div>
						<aside class="notes">
							KJ: Ja nazywam się Krzysztof Jura, przyjechałem do was z Częstochowy, z Parkitki, czyli miałem dość niedaleko.

							Jeżeli chodzi o mnie to ja, programuję od 2007 roku, zaczynałem hobbistycznie od pisania sieciowych gier komputerowych 2D, a od ponad 5 lat pracuję w zawodzie, jako programista.
							Głównie zajmuję się tworzeniem aplikacji internetowych, zarówno po stronie backendu, który piszę w Pythonie, jak i po stronie frontendu, który oczywiście piszę w JavaScripcie.
							W ogóle, bardzo możliwe, że jakaś część z was korzysta na codzień z jakiś systemów nad którymi w przeszłości pracowałem, np. z systemu bankowego banku PKO BP.
							
							Oprócz tego, że programuję to od lat dorywczo zajmuję się nauczaniem programowania, zarówno prywanie jak i w szkołach programowania.

							Jestem też założycielem fanpage'a Częstochowskiej Społeczności Użytkowników języka Python. Obecnie na tym fanpage'u nic się nie dzieje, ale mamy w planach organizacje spotkań programistów Pythona, a w najbliższej przyszłości będziemy organizowali darmowe warsztaty z programowania w języku Python. Warsztaty będą dla każdego niezależnie od płci, wieku, rasy, wyznania, orientacji seksualnej czy poglądów politycznych, więc każdego zainteresowanego zapraszam do polubienia fanpage'a i oczekiwania na dalsze informacje.
						
							I to by było na tyle jeżeli chodzi o nas prywatnie, natomiast chciałbym jeszcze opowiedzieć o projekcie w którym oboje z Arturem bierzmy udział.
						</aside>
					</section>
					
					<section data-transition="slide">
						<img src="rsc/LogoDK.png" class="logo" style="max-height: 250px;">
						<img src="rsc/dkscreen.jpg" style="max-height: 300px;">
						
						<aside class="notes">
							KJ: Projekt ten nazywa się Gothic II Dzieje Khorinis. Bardzo możliwe, że już słyszeliście tą nazwę bo jest o nas dość głośno.
							Tak w skrócie: robimy moda do kultowej gry o nazwie Gothic II. W naszym zespole mamy kilkadziesiąt osób, w tym m.in. programistów, scenarzystów, grafików, animatorów i pewnie jeszcze kilka innych typów osób. Natomiast nadal szukamy ludzi, więc jeżeli ktoś jest chętny nas wesprzeć to możemy pogadać o tym po tej prezentacji. Warto dodać, że projekt jest non profit, to znaczy nie dostajemy żadnych pieniędzy za pracę; po prostu pracujemy bo chcemy zrobić coś fajnego.
							
							Jeżeli chodzi o historię projektu to pomysł na zrobienie moda powstał w 2008 roku, ale dopiero pod koniec roku 2015 rozpoczęły się nad nim prace.
							Natomiast zgromadzenie zespołu w takim kształcie w jakim mniej więcej teraz jest to w zasadzie kwestia ostatniego roku.
							
							Z takich ciekawostek to: do naszego moda głosów udzielają profesjonalni aktorzy głosowi, w tym również Ci, którzy podkładali głos postaciom z oryginalnej wersji gry.
							
							Oprócz samego moda, w naszym zespole pracujemy również nad narzędziami związanymi z modowaniem Gothica. Głównym językiem, który wykorzystujemy w tych narzędziach jest C#, a o samych narzędziach opowie wam Artur.
							
						</aside>
					</section>
				</section>
				
				<section data-transition="slide">
					<h3 style="text-align:left">Tools</h3><br>
					<div class="sl-block" data-block-type="text">
						<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
							<ul>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">3D World Editor</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Mod Package Builder</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Translation Tool</li>
								<li class="fragment fade-in-then-semi-out" style="text-align:left">Daedalus Compiler</li>
							</ul>
						</div>
					</div><br>
					
					<aside class="notes">
							AK: Narzędzi, które tworzymy jest dość dużo, natomiast takie główne 3 narzędzia to przede wszystkim:
							
							- Edytor Światów, który ma w założeniu być dużo bardziej rozbudowanym i dopracowanym edytorem niż ten dołączony do Gothica. Ten Gothicowy wiecznie się zawiesza, chodzi bardzo topornie i częśc społeczności generalnie klnie na niego.

							- Kolejnym naszym projektem jest narzędzie do budowania paczki z modem, które zbiera do kupy cały kod projektu, mapy, modele i inne rzeczy i buduje z nich paczkę o oczekiwanym przez Gothica formacie.

							- Pracujemy także nad narzędziem które pozwoli w łatwiejszy sposób dodać lokalizacje językowe, obecnie by dodać nową wersję językową tłumacz musi grzebać bezpośrednio w skryptach i np podmieniać literały, co grozi bugami w danej wersji językowe

							- No i ostatnim narzędziem jest Kompilator języka Daedalus, o którym dzisiaj wam troszkę więcej opowiemy.
					</aside>
				</section>
				
				
				
				
				<section class="stack">
					<section data-transition="slide">
						<h3>Daedalus</h3><br>
						<img class="fragment fade-in" src="rsc/wtfmeme.png" style="max-height: 300px;">
						
						<aside class="notes">
							Pytanie do publiczności: czy ktoś z was w ogóle słyszał o takim języku jak Daedalus?
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3 style="text-align:left">Daedalus</h3><br>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">Gothic I and II scripting language</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">has C-like syntax</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">compiled to Daedalus bytecode</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">have externals which call engine functions directly</li>
								</ul>
							</div>
						</div><br>
						
						<aside class="notes">
							Daedalus którego nazwa pochodzi od mitycznego Dedala to po prostu język skryptowy gier Gothic I i Gothic II, czyli język w którym pisze się mody do tych gier.
							
							Jego składnia została zainspirowana składnią języka C co widać już na 1 rzut oka.
							
							A kod tego języka jest kompilowany do kodu bajtowego, wykonywanego w trakcie gry przez maszynę wirtualną zawartą w grze Gothic.

							Za pomocą externali jest możliwe wywołanie różnych funkcji które są zaimplementowane na poziomie silnika, np logi
							
							<!--
							Mówimy że dzięki skryptom w D komuniukujemy się z silnkiem gry,
							w D istnieją internale do silnika, np AI_output które sterują zachowaniem
							silnika. Typowa architektura jak dla gier koło 2000 roku, Quake 3 podobnie działa ( C QUAKE )
								-->
						</aside>
					</section>

					
					<section data-background-transition="slide">
						<pre><code data-trim data-noescape>
instance PC_Thief_DI(Npc_Default)
{
  name[0] = "Diego";
  guild = GIL_NONE;
  npcType = NPCTYPE_FRIEND;
  aivar[AIV_ToughGuy] = TRUE;
  B_SetAttributesToChapter(self,6);
  fight_tactic = FAI_HUMAN_MASTER;
  EquipItem(self,ItMw_1h_Sld_Sword);
  daily_routine = Rtn_Start_31;
  ...
};
		</code></pre>

						<aside class="notes">
							Tutaj widzicie przykładowy kod w języku Daedalus. Jest to kod definiujący instancję NPCta, którego później w trakcie gry będziemy mogli spotkać na mapie.
							
							Ustalamy tutaj imie tego NPCta, jego model 3D, zachowanie, statystyki i inne parametry.
						</aside>
					</section>
					
					
					
					<section data-background-transition="slide">
						<pre><code data-trim data-noescape style="overflow: hidden;">
func void DIA_MIL_6_STANDARD_Info()
{
  AI_Output(other,self,"DIA_MIL_15_00");  //Co słychać?
  if(Kapitel == 1)
  {
    AI_Output(self,other,"DIA_MIL_06_01"); //W mieście coraz więcej szumowin.
    AI_Output(self,other,"DIA_MIL_06_02"); //Wszędzie coraz więcej złodziei. Lord Andre podejrzewa nawet, że całe to zamieszanie jest sprawką gangu.
    AI_Output(self,other,"DIA_MIL_06_03"); //Niedawno przetrząsnęliśmy dokładnie całą dzielnicę portową, ale niczego nie znaleźliśmy.
  }
  else if(Kapitel == 2)
  {
    AI_Output(self,other,"DIA_MIL_06_04"); //Wygląda na to, że problem bandytów mamy już z głowy. Ataki stały się ostatnimi czasy rzadkością.
  };
};
		</code></pre>

						<aside class="notes">
							Kolejny przykład kodu przedstawia funkcję dialogową zawierającą kwestie wypowiadane przez naszą postać oznaczoną przez self oraz przez postać z którą rozmawiamy oznaczoną przez other.
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Daedalus Compiler</h3><br>
						<img class="fragment fade-in" src="rsc/butwhy.gif" style="height: 300px; width: 550px; object-fit: cover;">
						
						<aside class="notes">
							No dobra, wiemy czym jest język Daedalus, ale pytanie brzmi: dlaczego w ogóle chcieliśmy stworzyć nowy kompilator tego języka?
							
							Powodów jest kilka.
							
							<!-- Skrypter nie może szybko przekompilować rzeczy bez odpalania gry, musi przewinąć intro
							Nie możemy przez to łatwo postawić stagingu który by testował automatycznie czy
							skrypty są kompilowanlne w naszym pipeline -->
							
							<!-- Kompilator będzie dopełnieniem narzędzia do budowania gry ( robocza nazwa gothic mod composer ).
							Dzięki temu nawet niedoświadczony skrypter będzie mógł w prosty sposób zacząć zabawę z modowaniem
							gothica -->
							
							Jednym z głównych powodów jest to, że oryginalny kompilator jest wbudowany w grę Gothic i żeby skompilować skrypty trzeba tą grę najpierw uruchomić - co jest dość niefajne,
							bo po pierwsze trzeba mieć zainstalowanego Gothica, a po drugie, po prostu gorzej się z takiego kompilatora korzysta - no bo trzeba za każdym razem czekać na uruchomienie gry, a potem wyjść z gry.
							
							Kolejna sprawa to jest to, że błędy wyświetlane przez oryginalny kompilator są często dość niejasne i enigmatyczne i w naszym kompilatorze chcielibyśmy to zrobić lepiej.
							
							No a poza tym sam język Daedalus w wersji dla oryginalnego kompilatora jest językiem dość mocno ograniczonym, więc mamy pomysł aby nasz kompilator potrafił obsługiwać bardziej rozbudowaną wersję tego języka, ale zachowując kompatybilność wsteczną , to znaczy, że oryginalny kod w języku Daedalus również działałby u nas bez problemu.
						</aside>
					</section>
					

					
					<section data-transition="slide">
						<h3 style="text-align:left">Daedalus flaws</h3>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">no for or while loop</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">has classes but no methods</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">requires ; after }</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">constants can be modified</li>
								</ul>
							</div>
						</div>
						
						<aside class="notes">
							Jakie są te ograniczenia języka Daedauls, których chcielibyśmy się pozbyć w naszej wersji języka?
							
							Jest ich generalnie bardzo dużo, a kilka takich pierwszych z brzegu, które od razu przychodzą na myśl to np. to, że:
							
							- w języku Daedalus nie ma pętli, ani for, ani while, ani foreach, ani żadnej innej, natomiast w naszej wersji języka chcemy je dodać
							
							- kolejne ograniczenie to to, że w Daedalusie istnieją klasy, natomiast nie mogą posiadać one metod, więc są de facto tylko stukturami danych i chcielibyśmy to zmienić

							- Kolejna sprawa to to, że oryginalny kompilator wymaga umieszczania średników po zamykających nawiasach wąsatych, co może być dość wkurzające dla programistów innych języków nieprzyzwyczajonych do takich rzeczy.
							
							- również dziwną rzeczą jest to, że stałe można w języku Daedalus modyfikować, a od zmiennych różnią się one tym, że nie są zapisywane w save'ach. My raczej nie będziemy chcieli dawać programistom możliwości zmiany wartości stałych.

							
							Genealnie tych ograniczń języka Daedalus jest dużo dużo więcej, więc naprawdę możemy ten język bardzo ulepszyć i mam nadzieję, że nam się to uda.
							
							No dobra, wróćmy do głównego tematu: czyli do tematu tworzenia kompilatora. Ale najpierw zadam pytanie: czy każdy z was wie czym dokładnie jest kompilator? Pewnie nie każdy.
						</aside>
					</section>
				</section>

				<section class="stack">
					<section data-transition="slide">
						<h3>Compiler</h3>
						<p class="fragment fade-in">A compiler is computer software that transforms computer code written in one programming language (the source language) into another programming language (the target language).</p>
						
						<aside class="notes">
							Zacznijmy od tego, czy jest kompilator. 
							
							Pozwólcie, że przedstawie wam definicje z angielskiej wikipedii, która mówi, że kompilator to jest program, który zamienia kod napisany w jednym języku programowania na kod w innym języku programowania. Kod źródłowy na kod docelowy.
							
							Zazwyczaj jak mówimy o kompilatorze  to mamy na myśli coś w stylu kompilatora np. języka C, czyli chodzi nam o program, który zamienia kod źródłowy na kod maszynowy, czyli instrukcje zrozumiałe dla procesora naszego komputera,

							albo czasmi chodzi nam o program, który zamienia kod źródłowy na kod bajtowy, który potem jest może być wykonany przez maszynę wirtualną i tak jest np. w przypadku np. Javy albo właśnie języka Daedalus.
						</aside>
					</section>
					
					
					
					
					<section data-transition="slide">
						<h3>How does the compiler work?</h3>
						
						<aside class="notes">
							No dobra, ale jak kompilator działa pod spodem? Otóż należy zacząć od tego, że kompilator to taki program, który jak sama nazwa wskazuje, potrafi wykonać proces kompilacji, który składa się z 4 głównych kroków.
							
							Pierwszym krokiem jest analiza leksykalna,
							Następnie mamy Parsowanie, czyli analizę syntaktyczą.
							Następnie odbywa się analiza semantyczna i mniej więcej w tym samym czasie również odbywa się generowanie pormy pośredniej, czyli Intermediate Representation generation
							i na koniec mamy generowanie kodu.
							
							W niektórych źródłach odnośnie kompilatorów możecie znaleźć mniej lub więcej kroków procesu kompilacji, często można znaleźć informacje o tym, że przed analizą leksykalną występuje też tkz. preprocesing. Czyli jeżeli ktoś pisał np. w C albo w C++ to tam te linie, które zaczynają się od # np. #include, albo #define one są właśnie wykonywane przez preprocesor przed krokiem
							analizy leksykalnej.
							
							Można by też do tego procesu kompilacji dołożyć ewentualnie optymalizacje kodu, który odbywa się zazwyczaj po wygenerowaniu formy pośredniej.
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Compilation</h3>
						<div class="fragment fade-in">
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">1. lexical analysis</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">2. parsing (syntactic analysis)</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">3. semantic analysis, IR generation</p>
							<p style="text-align:left; margin-bottom: 30px; margin-top: 30px;">4. code generation</p>
						</div><br>

						<aside class="notes">
		
						</aside>
					</section>
					
					<!--
					
					<section data-transition="slide">
						<h3>Compilation steps</h3>
						<div class="sl-block" data-block-type="text">
							<div class="sl-block-content" style="z-index: 12; line-height: 1.95;">
								<ul>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">preprocessing</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">lexical analysis</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">parsing</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">semantic analysis</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">intermediate form generation</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">optimization</li>
									<li class="fragment fade-in-then-semi-out" style="text-align:left">code generation</li>
								</ul>
							</div>
						</div>
						
						<aside class="notes">
		
						</aside>
					</section>
					-->
					
					<!-- - Pierwszym krokiem jest tkz. preprocessing, czyli przetworzenie kodu źródłowego za pomocą dyrektyw preprocesora. Jeżeli ktoś z was pisał kod w C albo w C++ to chodzi o komendy zaczynające się od hashtaga, np. define albo include. W naszym kompilatorze póki co tego kroku nie ma i najprawdopodobniej nie będzie. -->
					
					<section data-transition="slide">
						<h3>1. Lexical analysis</h3>
						<div style="align-items: center; display: flex;">
						
						<pre class="fragment fade-in" style="width:35%; float:left;"><code data-trim data-noescape style="overflow: hidden;">
func void testFunc() {
  var int x;
  x = HLP_Random(100);
  if (x >= 50) {
    Print("You win!");
  } else {
    Print("You lose");
  };
};
			</code></pre>
			
			<p class="fragment fade-in" style="float: left;margin-left: 2%;margin-right: 1%;padding: 0; font-size:200%">&#129094;</p>
			
			<pre class="fragment fade-in" style="width:52%; float:left; font-size: 0.45em;"><code data-trim data-noescape style="overflow: hidden;">
Token('func', &lt;FUNC>&gt;
Token('void', &lt;VOID>&gt;
Token('testFunc', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('var', &lt;VAR>&gt;
Token('int', &lt;INT>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('=', &lt;ASSIGN>&gt;
Token('HLP_Random', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('100', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('if', &lt;IF>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('>=', &lt;GREATER_THAN_EQUALS>&gt;
Token('50', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You win!"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token('else', &lt;ELSE>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You lose"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
			</code></pre>
			
			
						</div>
						<aside class="notes">
							No dobra, przejdźmy do pierwszego kroku, czyli analizy leksykalnej, która jest wykonywana przez część kompilatora o nazwie Lexer, nazywany czasem też Skanerem.
							
							Generalnie to działa tak, że Lexer dostaje na wejściu kod źródłowy i zamienia go na strumień Tokenów.
							Widzimy, że każde słowo kluczowe, nawiasy, czy średniki, liczby w zasadzie wszystko, zamieniane jest na tokeny.
							
							W tym przykładzie widzimy, że np. słowa func, później void, później testFunc zostały zamienione na tokeny, ale np.
							białe znaki, czyli spacje, albo znaki nowej linii zostały zignorowane i nie zostały z nich utworzone tokeny.
							
							Dlaczego? Ano dlatego, że Lexer został stworzony właśnie w taki sposób aby je ignorować.
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3>2. Parsing (syntactic analysis)</h3>
						
						<img class="fragment fade-in" src="rsc/antlr4_parse_tree.png" style="background: white;">
						
						<aside class="notes">
							Kolejnym krokiem kompilacji jest Analiza składniowa nazywana parsowaniem, która jest wykonywana przez Parser.
							
							W tym kroku Parser dostaje od Lexera strumień tokenów, analizuje je, i wg. ustalonych ściśle zasad, generuje
							z nich jakąś strukturę danych, zazwyczaj bedzie to drzewo składniowe, z angielskiego Abstract Syntax Tree, AST.
							
							Na takim drzewie bardzo fajnie widać strukturę kodu źródłowego, widać które tokeny składają się na deklaracje zmiennej, które na instukcje przypisania, a które na instrukcje warunkową.  

							I do tego w dość prosty, bo przechodząc po prostu po tym drzewie, można można z niego wyciągnąć wszelkie informacje potrzebne w dalszych krokach kompilacji.
							
							Warto dodać, że wszelkie błędy składniowe, które pewnie nie raz wam wyskakują podczas kompilowania swoich programów są wykrywane podczas Analizy składniowej. Błędy składniowe czyli oczywiście syntax errors po angielsku.
							</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>3. Semantic analysis</h3>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int random;
radom = 5;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int num;
num = "five";
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
var int x;
var int x;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
object.nonExistingAttribute = 100;
						</code></pre>
						<pre class="fragment fade-in"><code data-trim data-noescape>
func int testFunc() {};
						</code></pre>
						<aside class="notes">
							No dobra, kolejnym krokiem kompilacji jest analiza semantyczna.
							której zadaniem jest wykrywanie błędów semantycznych zwanych inaczej błędami znaczeniowymi.
							
							Są to takie błędy, o których nie można jednoznacznie stwierdzić, czy to są błędy
							czy nie, dopóki nie pozna się pełnego kontekstu.
							
							Przykład, jeżeli zobaczylibyśmy tylko linie radom = 5, no to nie jesteśmy w stanie stwierdzić,
							czy w tej linii jest błąd czy go nie ma. Ta linia wydaje się całkowicie poprawna.
							Ale, jeżeli spojrzymy na linijke wcześniej, to się okaże,że ta zmienna, do której przypisujemy
							wartość to się nie powinna nazywać radom, lecz random, więc mamy tutaj błąd semantyczny.
							
							Kolejnym przykładem takiego błędu jest przypadek, gdy próbujemy do zmiennej o jednym
							typie wpisać wartość innego typu.
							
							Albo np. kiedy 2 razy zadeklarujemy zmienną o tej samej nazwie.
							
							Lub np. w przypadku, gdy odwołamy się do jakiegoś nieistniejącego atrybutu obiektu.
							
							Albo kiedy funkcja powinna zwracać wartość jakiegoś typu, np. liczbowego, a nie zwraca nic.
							
						</aside>
					</section>
					
					<section data-transition="slide">
						<h4>3. Intermediate representation generation</h4>
						
						<div class="fragment fade-in" style="align-items: center; display: flex;">
						<pre style="width:32%; float:left;  font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
func void testFunc() {
  var int x;
<mark style="background: darkolivegreen;">  x = HLP_Random(100);</mark>
<mark style="background: darkslateblue;">  if (x >= 50)</mark>
<mark style="background: brown;">  {
    Print("You win!");
  }</mark>
<mark style="background: darkslategrey;">  else</mark>
<mark style="background: saddlebrown;">  {
    Print("You lose");
  };</mark>
<mark style="background: darkcyan;">};</mark>
			</code></pre>
			
			<p style="float: left;margin:0;padding: 0; font-size:100%">&#129094;</p>
			
			<pre style="width:35%; float:left; font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
<mark style="background: darkolivegreen;">PushInt(100)
CallExternal(HLP_Random)
PushVar(testFunc.x)
Assign()</mark>
<mark style="background: darkslateblue;">PushInt(50)
PushVar(testFunc.x)
GreaterOrEqual()
JumpIfToLabel("label_0")</mark>
<mark style="background: brown;">PushVar(˙10000)
CallExternal(Print)
JumpToLabel("label_1")</mark>
<mark style="background: darkslategrey;">AssemblyLabel("label_0")</mark>
<mark style="background: saddlebrown;">PushVar(˙10001)
CallExternal(Print)
AssemblyLabel("label_1")</mark>
<mark style="background: darkcyan;">Ret()</mark>
			</code></pre>
			
						<pre style="width:25%; float:left; font-size: 0.50em;"><code data-trim data-noescape style="overflow: hidden;">
<mark style="background:rgb(40,40,40);">HLP_Random
...
Print</mark>
testFunc
testFunc.x
˙10000 "You win"
˙10001 "You lose"
			</code></pre>
			
						</div>
						<aside class="notes">
							No dobra, przejdźmy dalej.
							
							Mniej więcej w tym samym czasie, w którym odbywa się analiza semantyczna, wykonywane jest też generowanie formy pośredniej.
							
							Polega to na wyciągnięciu danych z drzewa składniowego i zapisanie ich w odpowiednich strukturach w naszym programie, aby później w łatwy sposób można było wygenerować kod bajtowy.
							
							Ok, Chciałbym wam teraz zaprezentować wam jak wygląda u nas w kompilatorze ta forma pośrednia, i w jaki sposób ma się do niej kod źródłowy.
							
							Po lewej stronie mamy kod źródłowy, a po prawej mamy naszą formę pośrednią.
							Nasza forma pośrednia składa się w zasadzie na 2 listy. Pierwsza lista 
							jest to lista obiektów reprezentujących instrukcje asemblera Daedalusowego.
							I kolorami tutaj oznaczyłem, linie w kodzie źródłowym oraz odpowiadające im instrukcje.
							
							Widać np. że, linjka x = HLP_Random(100); zamienia się na 4 instrukcje, gdzi najpierw wrzucamy
							na stos wartość 100, następnie wywołujemy funkcję zewnętrzną HLP_Random, poźniej na stos wrzucamy zmienną X oraz wykonujemy instrukcje przypisania.
							
							Oprócz listy instrukcji, nasza forma pośrednia zawiera również listę symboli, czyli wszystkich klas, funkcji, zmiennych, stałych i tak dalej. Oprócz naszych własnych symboli na tej liście znajduje się też masa symboli reprezentujących funkcje zewnętrzne języka takie jak np. HLP_Random albo Print.
							
							Byćmoże ktoś z was zauważył albo i nie, ale z literałów napisów, czyli tych stringów w podwójnych apostrofach, również generowane są u nas symbole, których nazwa zaczyna się od kolejno od 10000 i idzie w górę, a zrobiliśmy to po prostu na wzór oryginalnego kompilatora Gothicowego. 
						</aside>
					</section>
					
					<section data-transition="slide">
						<h3>4. Code generation</h3>
						
						<img class="fragment fade-in-then-disappear" src="rsc/hxdhighlight.png">
						
						<div class="fragment fade-in" style="align-items: center; display: flex;">
						<pre style="width:35%; float:left; font-size: 0.50em; margin-left:18%;"><code data-trim data-noescape style="overflow: hidden;">
PushInt(100)
CallExternal(HLP_Random)
PushVar(testFunc.x)
Assign()
PushInt(50)
PushVar(testFunc.x)
GreaterOrEqual()
JumpIfToLabel("label_0")
PushVar(˙10000)
CallExternal(Print)
JumpToLabel("label_1")
AssemblyLabel("label_0")
PushVar(˙10001)
CallExternal(Print)
AssemblyLabel("label_1")
Ret()
						</code></pre>
						<p style="float: left;margin:0;padding: 0; font-size:100%">&#129094;</p>
						<pre style="width:21%; float:left; font-size: 0.50em;  margin-right:18%;"><code data-trim data-noescape style="overflow: hidden;">
40 64 00 00 00
3E 57 02 00 00
41 AC 03 00 00
09
40 32 00 00 00
41 AC 03 00 00
12
4C 2F 00 00 00
41 AD 03 00 00
3E 0C 00 00 00
4B 39 00 00 00

41 AE 03 00 00
3E 0C 00 00 00

3C
						</code></pre>
						</div>
						
						
						<aside class="notes">
							Ostatnim krokiem jest wygenerowanie kodu, w naszym przypadku to będzie kod bajtowy dla maszyny wirtualnej Gothica. A tak będąc dosłownym to wynikiem tej kompilacji jest plik o nazwie gothic.dat który zawiera w sobie informacje o wzystkich symbolach oraz kod bajtowy.
							
							Ja te plik sobie wygenerowałem i później otworzyłem hex edytorem, aby podejrzeć
							poszczególne bajty. I tutaj mamy screen z tego hex edytora, widzimy po prawej stronie, zaznaczyłem nazwy symboli oraz wartości tekstowe, które pochodzą z kodu źródłowego, natomiast po lewej stronie zaznaczyłem wartości 40 i 3C i są to odpowiednio, początek oraz koniec wygenerowanego kodu bajtowego, który jest de facto kodem naszej funkcji.
							
							Z czego wygenerowaliśmy ten kod bajtowy? Ano listy instrukcji zawartej w naszej formie pośredniej. Tutaj również widać, że pierwszy bajt to 40, a ostani bajt to 3C.
							
							Fajnie też widać, że pierwszy bajt w każdym wierszu po prawej stronie to po prostu kod instrukcji, oczywiście w formacie szesnastkowym. Dla przykładu: instrukcja PushInt generuje kod 40 szesnastkowo, argument tej instrukcji, czyli wartość 100 jest później zapisana na kolejnych 4 bajtach. Wartość 100 w systemie dziesiętnym to jest właśnie wartość 64 w systemie szesnastkowym.
							
							
						</aside>
					</section>
					
					<section data-background-transition="slide">
						<h3>Let's make a compiler</h3><br>
						<h4 class="fragment fade-in" style="text-align:left;"><span style="color:red;">Q:</span> What do I need to start?</h3>
						<h4 class="fragment fade-in" style="text-align:left;"><span style="color:darkolivegreen;">A:</span> C# + ANTLR4!</h3>
						<h4 class="fragment fade-in" style="text-align:left;"><span style="color:red;">Q:</span> Ok, done. What now?</h3>
						<h4 class="fragment fade-in" style="text-align:left;"><span style="color:darkolivegreen;">A:</span> Create lexical and syntactic grammar!</h3>
						<br><br>
						<aside class="notes">
						No dobra, jakieś podstawy procesu kompilacji już mamy, więc możemy spróbować zrobić kompilator.
						Pytanie czego potrzebujemy na początek?
						Możemy użyć różnych narzędzi, ale użyjemy narzędzi z tytułu prezentacji czyli powinniśmy zainstalować C#
						oraz narzędzie ANTLR4, napisane w Javie, więc Java też bedzie nam potrzebna, przynajmniej przez chwilę.
						No dobra, założmy, że to już mamy, i pytanie co teraz?
						Jaki jest pierwszy krok?
						Ano musimy stworzyć plik z gramatyką. W tym pliku bedzie znajdować się gramatyka leksykalna oraz gramatyka syntaktyczna, o których zaraz powiem.
						</aside>
					</section>
					
					<section data-background-transition="slide">
						<h3>Lexical grammar</h3>
						<pre class="fragment fade-in" style="width:60%; font-size: 0.45em;"><code class="html" data-trim data-noescape style="overflow: hidden;">
IF:              'if';
FUNC:            'func';
INT:             'int';
VAR:             'var';
VOID:            'void';
ELSE:            'else';
<mark style="background:darkred;">OPEN_PAREN:      '(';
CLOSE_PAREN:     ')';
OPEN_BRACE:      '{';
CLOSE_BRACE:     '}';
SEMICOLON:       ';';</mark>
INTEGER_LITERAL: [0-9]+;
STRING_LITERAL:  '"' (~["])* '"';
IDENTIFIER:      [a-zA-Z_][a-zA-Z0-9_]*;
<mark style="background:darkred;">ASSIGN:          '=';
GREATER_EQUAL:   '>=';</mark>
WHITESPACE:      [ \t]+ -> skip;
NEWLINE:         ('\r''\n'?| '\n') -> skip;
						</code></pre>

						<aside class="notes">
							Zacznijmy od gramatyki leksykalnej.
							Pytanie co to jest gramatyka leksykalna?
							
							Otóż jest to zbiór definicji TOKENów, o których już wcześniej wspominałem,
							gdy mówiłem o Lexerze, czyli części kompilatora zamieniającej kod źródłowy
							na strumień tokenów.
							
							Można powiedzieć też, że gramatyka leksykalna to jest swego rodzaju słownik naszego języka,
							ponieważ wymienione są w niej wszystkie słowa, które mogą w naszym języku wystąpić.
							
							W jaki sposób definiujemy tokeny?
							Ano najpierw piszemy nazwe tokenu, a po dwukropku piszemy tekst, lub wyrażenie regularne, któremu
							on odpowiada. Co to, że tekst odpowiada TOKENowi? Ano to, że jeżeli w kodzie źródłowym wystąpi taki tekst 
							lub tekst, który pasuje do zapisanego wyrażenia reglarnego to zostanie wygenerowany ten TOKEN.
							
							Widzimy, że ja na początku zdefiniowałem sobie słowa kluczowe.
							Potem nawiasy, średnik, liczbe całkowitą, napis, następnie identyfikator,
							który będzie używany jako nazwa dla klas, funkcji, zmiennych i tego typu rzeczy.
							
							Później zdefiniowałem sobie operatory.
							
							A na końcu białe znaki i znaki nowej linii,
							które onaczyłem, że chciałbym skipować, czyli ignorować.
							
							
							/*
							O TYM POWIEM INNYM RAZEM JAK BĘDZIE WIĘCEJ CZASU:
							Dopasowywane są te zasady, które są w stanie dopasować jak najwięcej tekstu z kodu źródłowego.
							Np. gdyby ktoś chciał nazwać zmienną ifs, no to zostanie z tego stworzony token if, lecz token identifier.
							
							W przypadku równej długości dopasowania kolejność jest ważna, jeżeli np. IDENTIFIER byłby nad IFem to nigdy token if by nie wystąpił.
							bo wyrazęnie if (cośtam) by generowało IDENTIFIER.
							*/
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Lexical analysis</h3>
						<div style="align-items: center; display: flex;">
						
						<pre style="width:35%; float:left;"><code data-trim data-noescape style="overflow: hidden;">
func void testFunc() {
  var int x;
  x = HLP_Random(100);
  if (x >= 50) {
    Print("You win!");
  } else {
    Print("You lose");
  };
};
			</code></pre>
			
			<p style="float: left;margin-left: 2%;margin-right: 1%;padding: 0; font-size:200%">&#129094;</p>
			
			<pre style="width:52%; float:left; font-size: 0.45em;"><code data-trim data-noescape style="overflow: hidden;">
Token('func', &lt;FUNC>&gt;
Token('void', &lt;VOID>&gt;
Token('testFunc', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('var', &lt;VAR>&gt;
Token('int', &lt;INT>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('=', &lt;ASSIGN>&gt;
Token('HLP_Random', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('100', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('if', &lt;IF>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('x', &lt;IDENTIFIER>&gt;
Token('>=', &lt;GREATER_THAN_EQUALS>&gt;
Token('50', &lt;INTEGER_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You win!"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token('else', &lt;ELSE>&gt;
Token('{', &lt;OPEN_BRACE>&gt;
Token('Print', &lt;IDENTIFIER>&gt;
Token('(', &lt;OPEN_PAREN>&gt;
Token('"You lose"', &lt;STRING_LITERAL>&gt;
Token(')', &lt;CLOSE_PAREN>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
Token('}', &lt;CLOSE_BRACE>&gt;
Token(';', &lt;SEMICOLON>&gt;
			</code></pre>
			
			
						</div>
						<aside class="notes">

						</aside>
					</section>
					
					
					<section data-background-transition="slide">
						<h3>Syntactic grammar</h3>
						<pre class="fragment fade-in" style="font-size: 0.45em;"><code class="html" data-trim data-noescape style="overflow: hidden;">
main: functionDef* EOF;

functionDef: FUNC VOID IDENTIFIER '(' ')' block ';';
block: '{' statement* '}';
statement: (assignment | varDecl | functionCall | ifStatement) ';';

assignment: IDENTIFIER '=' expression;
varDecl: VAR INT IDENTIFIER;
functionCall: IDENTIFIER '(' expression ')';

ifStatement: IF ifCondition block (ELSE block)? ';';
ifCondition: '(' expression ')';

expression: expression '>=' expression | functionCall | value;

value: INTEGER_LITERAL | STRING_LITERAL | IDENTIFIER;
						</code></pre>

						<aside class="notes">
							No dobra, pytanie czym jest gramatyka syntaktyczna?
							
							W skrócie można powiedzieć, że jest to zbiór zasad opisujących strukturę naszego języka.
							
							Czyli inaczej można powiedzieć, że tej gramatyce piszemy zasady, które określają w jaki sposób ma wyglądać składnia naszego języka,
							jak mają być zapisywane definicje funkcji, wyrażenia warunkowe, pętle, jak ma wyglądać deklaracja zmiennych i inne tego typu rzeczy.
							Również rzeczy typu czy bloki kodu mają być wyznaczone klamrami, czy może wcięciami jak w Pythonie, a może jeszcze inaczej?
							
							
							Zapis wygląda w taki sposób, że najpierw piszemy nazwę zasady, a po dwukropku jej opis.
							Jeżeli chodzi o nazwy tych zasad to są one dowolne, to my decydujemy jak się będą nazywać.
							
							Opis zasady może zawierać odwołania do TOKENów oraz do innych zasad.
							Można też odwoływać się do tokenów nie po nazwie, lecz po dopasowaniu.
							Robimy to za pomocą umieszczenia napisu w pojedynczych apostrofach.
							I wtedy to działa tak fajnie, że de facto nie musimy mieć zdefiniowanych tych tokenów
							bo one zostaną automatycznie wygenerowane przez ANTLR4.
							
							Możemy też tutaj korzystać z kwantyfikatorów wyrażeń regularnych takich jak:
							* - oznaczająca 0 lub więcej wystąpień wyrażenia poprzedzającego
							+ - 1 lub więcej wystąpień
							? - opcjonalność (0 lub 1 wystąpienie)
						</aside>
					</section>
					
					
					<section data-transition="slide">
						<h3>Parsing (syntactic analysis)</h3>
						
						<img src="rsc/antlr4_parse_tree.png" style="background: white;">
						
						<aside class="notes">
						W ramach przypomninia to ta gramatya jest po to, żeby wygenerować parser, który według ściśle określonych regół będzie wstanie zamienić strumień tokenów na drzewo składniowe.
						</aside>
					</section>
					
					
					<section data-background-transition="slide">
						<h4>Daedalus.g4</h4>
						<pre class="fragment fade-in" style="width: 70%; font-size: 0.32em;"><code class="html" data-trim data-noescape style="overflow: hidden;">
grammar Daedalus

IF:              'if';
FUNC:            'func';
INT:             'int';
VAR:             'var';
VOID:            'void';
ELSE:            'else';
INTEGER_LITERAL: [0-9]+;
STRING_LITERAL:  '"' (~["])* '"';
IDENTIFIER:      [a-zA-Z_][a-zA-Z0-9_]*;
WHITESPACE:      [ \t]+ -> skip;
NEWLINE:         ('\r''\n'?| '\n') -> skip;

main: functionDef* EOF;
functionDef: FUNC VOID IDENTIFIER '(' ')' block ';';
block: '{' statement* '}';
statement: (assignment | varDecl | functionCall | ifStatement) ';' ;
assignment: IDENTIFIER '=' expression;
varDecl: VAR INT IDENTIFIER;
functionCall: IDENTIFIER '(' expression ')';
ifStatement: IF ifCondition block (ELSE block)? ';';
ifCondition: '(' expression ')';
expression: expression '>=' expression | functionCall | value;
value: INTEGER_LITERAL | STRING_LITERAL | IDENTIFIER;
						</code></pre>

						<aside class="notes">

						</aside>
					</section>

					<section data-background-transition="slide">
						<h4>Generate Lexer, Parser and Listener</h4>
						<pre class="fragment fade-in"><code class="nohighlight" data-trim data-noescape style="overflow: hidden; background:black;">
<span class="fragment fade-in">λ ls</span>
<span class="fragment fade-in">Daedalus.g4</span>
<span class="fragment fade-in">λ antlr4 -Dlanguage=CSharp Daedalus.g4</span>
<span class="fragment fade-in">java org.antlr.v4.Tool -Dlanguage=CSharp Daedalus.g4</span>
<span class="fragment fade-in">λ ls</span>
<span class="fragment fade-in">Daedalus.g4              DaedalusLexer.interp
Daedalus.interp          DaedalusLexer.tokens
Daedalus.tokens          DaedalusListener.cs
DaedalusBaseListener.cs  DaedalusParser.cs
DaedalusLexer.cs</span>
						</code></pre>

						<aside class="notes">

						</aside>
					</section>
					
				</section>
				
				<section class="stack">
					<section>
						<h3>What our compiler can do for now moment ?</h3>
						<ul>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Load SRC file</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Compile Daedalus code and generate DAT file</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Detect errors with default ANTLR error strategy</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Generate CSL files ( Gothic Engine Dialog file )</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">Generate readable assembler (WIP)</li>
						</ul>

						<aside class="notes">
							Nad kompilatorem pracujemy już około 9 miesięcy, przez ten czas udało nam się już trochę osiągnąć.

							Udało nam się z suksecem załadować pełne skrypty Gothica II i wygenerować plik DAT który jest taki sam jak plik tworzony przez oryginalny kompilator. Dodatkowo nasz kompilator jest szybszy od oryginalnego.

							Dzięki antlr'owi mamy zaimplementowane wykrywanie błędów leksykalnych i semantycznych. Pracujemy nad ulepszeniem wykrywanie błędów semantycznych, ponieważ nie wszystkie da się wyłapać podczas procesu parsowania

							Generujemy pliki CSL. Są one tworzone na podstawie komenatrzy które są w kodzie. WIem że to dość dziwaczne trzymać w komentarzach dialogi ale było to wymyślane w 1999.

							Gdy dodamy odpowednią flagę zamiast pliku DAT generujemy pośredni assembler, który jest w pełni czytelny przez człowieka, ten feature wymaga dopracowania.

						</aside>
					</section>
					<section>
						<h3>Demo</h3>
						<img class="fragment fade-in-then-semi-out" src="rsc/demo.gif">

						<aside class="notes">
							Teraz czas na demo :). Dla pewności zrobiłem nagranie terminala w postaci GIFa. Zobaczmy co na nim jest

							Na początku tworzymy plik Gothic.src, plik ten zawiera inforamcji o lokalizacji naszych wszystkich źródeł.
							Następnie dodajemy plik z Daedalusem, dodajemy w nim testową funkcję, robimy operacje na lokalnej zmiennej

							Dalej kompilujemy plik src kompilatorem, kompilator mówi nam o braku średnika

							Poprawiamy to, kompilujemy jeszcze raz, tym razem kompilator kompiluje z sukcesem i generuje folder output

							W nim znadjuje się plik DAT, plik DAT jest plikiem binarnym z kodem maszynowym.
						</aside>
					</section>
					<section style="font-size: 80%">
						<h3>Some interesting problems during development</h3>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with encoding ( Gothic Script were written originally written in windows 1250 encoding  )
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with INSTANCE_HELP symbol name ( in byte code it's prefixed with fixed char, value of that char is 255  )
							<br/><br/><img width="400" src="rsc/instanceHelpProblem.png">
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Problem with slow compilation speed ( changing List to Dictionary resolved problem  )
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							dotNet Directory.GetFiles method by default works differently on different OS
						</li>

						<aside class="notes">
							Podczas developmentu napotkaliśmy kilka ciekawych problemów.

							Odkryliśmy, że skrypty gothica nie są kodowane w utf8, a w windows 1250. Pod koniec lat 90 utf8 nie było jeszcze
							tak popularne. Na szczęście w netcore w prosty sposób można wczytać stringa w kodowaniu 1250, tak samo w prosty sposób
							można przekonwertować spowrotem stringa do 1250

							Napotkaliśmy na problem z nazwą zmiennej w wynikowym pliku DAT. Mianowicie po kompilacji zmienna ta dostawała nowy znak do nazwy.
							Nasz kompilator czegoś takiego nie robił, skąd wyszły niezgodności między naszym DATem, a DATem oryginlnaego kompilatora,
							prostym IFem naprawiliśmy problem, na szczęście to jedyny taki przypadek z dodawaniem prefixów przez kompilator

							W pierwszych wersjach nasz kompilator strasznie powoli działał, okazało się że problem jest podczas przeszukiwania
							listy z symbolami, zamiana tejże listy na słownik przyspieszyła proces kompilacji kilkukrtonie

							Podczas testów na MacOS napotkałem na problemy. Okazało się że pliki są czytane w innej kolejnosci niż na windowsie, a
							to ma ogromne znaczenie podczas kompilacji, bo musi być zachowana prawidłowa kolejność parsowania plików,
							problem wynikał z wildcardów które są wspierane w plikach SRC. Funckja Directory.GetFiles jako jeden z argumentów ma
							pattern, w którym mozemy podać wildecard, na windowsie gdy mamy sytuacje że nazwa pliku jest prefixem innego pliku,
							to na posortowanej liście pierwszy będzie plik o dłuższej nazwie, na macOS działa to odwrotnie, pierwszy na liście będzię
							plik o krótszej nazwie, ten który jest prefixem
						</aside>
					</section>
					<section>
						<h3>Things about Daedalus discovered during compiler development</h3>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Operation on floats are limited
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Statement of IF block does't have to be surrounded with brackets, ex:
							<pre><code data-trim data-noescape>
if 5 < 2 {
};
							</code></pre>
						</li>
						<li class="fragment fade-in-then-semi-out" style="text-align:left">
							Gothic Compiler support expression without assigment
							<pre><code data-trim data-noescape>
if ( a > b ) {
  b;
};
							</code></pre>
						</li>

						<aside class="notes">
							Dzięki pracy nad kompilatorem udało nam się dowiedzieć kilka ciekawych rzeczy.

							Obsługa floatów jest bardzo kiepska. De facto to głównie służą jako parametry do różnych rzeczy w silniku.
							Nie ma na poziomie VM instukcji które pozwalałyby robić porównania floatów, czy też operacji dodawania etc

							Nie jest wymogiem dawanie nawiasów do wyrażeń w blokach warunkowych. Na początku myśleliśmy że jest to jakiś bug
							oryginlnaego kompilatra że na coś takiego pozwala, ale jak się później okazało to jednak feature ;). De facto
							tylko w jednym wyrażeniu twórcy gothica pokusili się o taką składnię.

							W gothicu dozwolne jest użycie wyrażenia w którym podajemy samą prawą wartość, w takim przypadku po prostu
							na stos jest wrzucana zmienna b, i nic wiecej. De facto taki kod nic nie robi, także trochę nie ma sensu,
							w oryginlnych skryptach gothica jest tylko takie jedno miejsce z takim expression
						</aside>
					</section>
					<section>
						<h3>What we plan to add ?</h3>
						<ul>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Better error handling
								<ul>
									<li>Lexical errors</li>
									<li>Semantic errors</li>
								</ul>
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add booleans ( software support )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add loops (for, while, foreach)
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Possibility to define methods in classes
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add translation string ( feature needed for translation tool )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								Add operations on float ( software support )
							</li>
							<li class="fragment fade-in-then-semi-out" style="text-align:left">
								And ... features suggested by You, community and all Daedalus users ;)
							</li>
						</ul>

						<aside class="notes">
							Planujemy rozszerzyć Daedalus o kilka istotnych funkcji.

							Chcielibyśmy ulepszyć wylrywanie błędów. Obecnie nie robimy analizy typów, co jest must have.
							Dodatkowo myślimy nad zmianą domyślnej strategi antlr związanej z detekcją błędów podczas
							parsowania kodu, dzięki czemu moglibyśmy mieć bardziej customową obsługę błędów.

							Dodać booleany. Niestety nie jest to możliwe na poziomie VM, także pod spodem byłyby
							dalej inty

							Dodać pętle, co ciekawe twórcy nie zdecydowali się na ich dodanie, w niektórych miejscach
							takowe pętle uprościłyby kod skrytpów

							Możliwość dodawania metod do klas, na dzień obecny można jedynie dodawać pola z wartościami do klas

							Obecnie niektóre teksty ktróre są wyswietlane w grze są trzymane jako literały Daedalusa. Przez to
							tłumacz musi grzebać w rzeczach abstrakcyjnych dla niego i dodatkowo może popsuć skrypty. Planujemy
							dodać mechanizm który pozwoli wyciągnać te teksty do zewnętrznych plików

							Planujemy dodać możliwość operacji na floatach, dzięki temu skrypterzy mieliby większe możliwości

							Także wy możecie zadecydować co chcecie zobaczyć w nowym Daedalusie. Jesteśmy otwarci na sugestie
						</aside>
					</section>
				</section>
				<section class="stack">
					<section style="font-size: 90%">
						<h3>Do we write tests ?</h3> <br/>
						<img class="fragment fade-in" width="500" src="rsc/testMeme.jpg"><br/>
						<h3 class="fragment fade-in">Just kidding!</h3>
						<h3 class="fragment fade-in">Yes, we do!</h3>
						<h3 class="fragment fade-in">And their helped us!!</h3>

						<aside class="notes">
							Pewnie się zastanawialiście się czy piszemy testy.

							Po cholere je pisać ...

							Nie no, żart, piszemy testy

							I myślę że warto, mieliśmy sytaucje że robiliśmy refactor, dzięki testom było to o wiele łatwieszje. Mamy też większą
							pewność że nowe featury nie zepsują obecnie dziajłająych rzeczy. Dodatkowo po dłuższej przerwie z kodem spoglądając na
							testy, może sobie przypomnieć jak wygląda i działa assembler VM daedalusa
						</aside>
					</section>
					<section>
						<h3>We write unit tests</h3>
						<img width="800" class="fragment fade-in" src="rsc/unitTest.png">
						<aside class="notes">
							W unit testach większość test casów ma kod w stringu Daedalusa oraz oczekiwane instrukcje kodu pośredniego,
							w teście uruchamiamy kompilator dla tego stringa i sprawdzamy czy instrukcje IR są takie jakie powinny być wygenerowane
						</aside>
					</section>
					<section>
						<h3>We write e2e tests</h3>
						<img src="rsc/e2eTest.png">
						<aside class="notes">
							W testach e2e międzyinnymi porównujemy czy plik DAT stworzony przez oryginalengo gothica jest zgodny
							z plikiem DAT stworzonym przez nas
						</aside>
					</section>
					<section>
						<h3>We use CircleCI for automation</h3>
						<img src="rsc/circleci.png">
						<aside class="notes">
							Projekt trzymamy na Githubie, dzięki circleCi możemy w bardzo prosty sposób odpalać testy za każdym razem gdy robimy
							merge, albo wysyłamy kod na dany branch
						</aside>
					</section>
					<section>
						<h3>Thanks to:</h3>
						<img width="300" src="rsc/dotnetcore.png">
						<div class="fragment fade-in">
							<h3>We can run compiler on:</h3>
							<img width="600" src="rsc/OS.png">
						</div>
						<aside class="notes">
							Dzięki temu że kompilator jest pisany w technologii dotnet core możemy uruchomić go na wszystkich znacząych systemach.
							Wcześniej było to możliwe na windowsie, ponieważ kompilator jest wbudowany w gothic2.exe, a gothic2.exe działa tyko na windowsie,
							zapominając o tym że jest coś takiego jak wine, uruchomienie na wine wymaga trochę kombinacji
						</aside>
					</section>
				</section>
				
				<section>
					<h3>We need C# programmers</h3>
				</section>
				
				<section>
					<h3>Thank you and Bye</h3> <br />
					<h3 class="fragment fade-in">Questions ?</h3>
					<br /><br />
					<img width="200" src="rsc/ghLogo.png"><br/>
					<a href="https://github.com/dzieje-khorinis/DaedalusCompiler">github.com/dzieje-khorinis/DaedalusCompiler</a>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

			// setTimeout(() => {
            //   Reveal.navigateTo(4)
			// }, 500);
		</script>
	</body>
</html>
